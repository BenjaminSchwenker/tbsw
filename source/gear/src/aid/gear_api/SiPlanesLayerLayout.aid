package hep.gear.api ;

/**Abstract description of layers in a pixel beam telescope.
 * @author T. Klimkovich, DESY
 * @version $Id: 
 */
public interface SiPlanesLayerLayout {
    
    /** The total number of layers. */

    public int getNLayers() const ;
    
     /** Layer ID of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.*/
    public int getID(int layerIndex) const ;
    
   /** The radiation length of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getLayerRadLength(int layerIndex) const ;

    /** The radiation length of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getSensitiveRadLength(int layerIndex) const ;

    /** x position of the center of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getLayerPositionX(int layerIndex) const ;

    /** y position of the center of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getLayerPositionY(int layerIndex) const ;

    /** z position of the center of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getLayerPositionZ(int layerIndex) const ;


    /** Size in x direction of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getLayerSizeX(int layerIndex) const ;


    /** Size in y direction of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getLayerSizeY(int layerIndex) const ;


    /** Thickness of nonsensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getLayerThickness(int layerIndex) const ;


    /** ID of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.*/
    
    public int getSensitiveID(int layerIndex) const ;
    
    /** Type of pixel layout (bricked/non bricked ) of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.*/
    public int getSensitivePixelType(int layerIndex) const ;
    
    /** x position of the center of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getSensitivePositionX(int layerIndex) const ;

    /** y position of the center of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getSensitivePositionY(int layerIndex) const ;

    /** z position of the center of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source.
     */
    public double getSensitivePositionZ(int layerIndex) const ;

    /** Size in x direction of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getSensitiveSizeX(int layerIndex) const ;

    /** Size in y direction of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getSensitiveSizeY(int layerIndex) const ;

    /** Thickness of sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */	
    public double getSensitiveThickness(int layerIndex) const ;

    /** Number of pixels in x direction in sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public int getSensitiveNpixelX(int layerIndex) const ;

    /** Number of pixels in y direction in sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public int getSensitiveNpixelY(int layerIndex) const;

    /** Pitch size in x direction in sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitivePitchX(int layerIndex) const;

    /** Pitch size in y direction in sensitive volume of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitivePitchY(int layerIndex) const;
    
    /** Intrinsic resolution in X of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveResolutionX(int layerIndex) const;
    
    /** Intrinsic resolution in Y of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveResolutionY(int layerIndex) const;
    
    /** 3D Euler rotation angle alpha  
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotationAlpha(int layerIndex) const; 
    
    /** 3D Euler rotation angle beta  
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotationBeta(int layerIndex) const; 
    
    /** 3D Euler rotation angle gamma  
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotationGamma(int layerIndex) const; 

    /** First element (cos(theta)) of rotation matrix of sensitive volume 
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotation1(int layerIndex) const;

    /** Second element (-sin(theta)) of rotation matrix of sensitive volume 
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotation2(int layerIndex) const;

    /** Third element (sin(theta)) of rotation matrix of sensitive volume 
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */
    public double getSensitiveRotation3(int layerIndex) const;

    /** Fourth element (cos(theta)) of rotation matrix of sensitive volume 
     *  of layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the beam source. 
     */

    public double getSensitiveRotation4(int layerIndex) const;

     /** ID of nonsensitive volume of the DUT.*/
    public int getDUTID() const ;

   /** The radiation length of nonsensitive volume of the DUT.
     */
    public double getDUTRadLength() const ;

    /** The radiation length of sensitive volume of the DUT.
     */
    public double getDUTSensitiveRadLength() const ;

    /** x position of the center of nonsensitive volume of the DUT. */ 
    public double getDUTPositionX() const ;
    /** y position of the center of nonsensitive volume of the DUT. */ 
    public double getDUTPositionY() const ;
    /** z position of the center of nonsensitive volume of the DUT. */ 
    public double getDUTPositionZ() const ;

    /** Size in x direction of nonsensitive volume of the DUT. */ 
    public double getDUTSizeX() const ;
    /** Size in y direction of nonsensitive volume of the DUT. */ 
    public double getDUTSizeY() const ;
    /** Thickness of nonsensitive layer of the DUT. */ 
    public double getDUTThickness() const ;

    /** ID of sensitive volume of the DUT. */
    public int getDUTSensitiveID() const ;

     /** Type of pixel layout (bricked/non bricked ) of the DUT. */
    public int getDUTSensitivePixelType() const ;

    /** x position of the center of sensitive volume of the DUT. */ 
    public double getDUTSensitivePositionX() const ;
    /** y position of the center of sensitive volume of the DUT. */ 
    public double getDUTSensitivePositionY() const ;
    /** z position of the center of sensitive volume of the DUT. */ 
    public double getDUTSensitivePositionZ() const ;

    /** Size in x direction of sensitive volume of the DUT. */ 
    public double getDUTSensitiveSizeX() const ;
    /** Size in y direction of sensitive volume of the DUT. */ 
    public double getDUTSensitiveSizeY() const ;
    /** Thickness of sensitive volume of the DUT. */ 
    public double getDUTSensitiveThickness() const ;

    /** Number of pixels in x direction of sensitive volume of the DUT. */ 
    public int getDUTSensitiveNpixelX() const ;
    /** Number of pixels in y direction of sensitive volume of the DUT. */ 
    public int getDUTSensitiveNpixelY() const;

    /** Pitch size in x direction of sensitive volume of the DUT. */ 
    public double getDUTSensitivePitchX() const;
    /** Pitch size in y direction of sensitive volume of the DUT. */ 
    public double getDUTSensitivePitchY() const;

    /** Intrinsic resolution in X of the DUT */ 
    public double getDUTSensitiveResolutionX() const;
    
    /** Intrinsic resolution in Y of the DUT */ 
    public double getDUTSensitiveResolutionY() const;
    
    /** 3D Euler rotation angle alpha of the DUT */
    public double getDUTSensitiveRotationAlpha() const; 
    
    /** 3D Euler rotation angle beta of the DUT */
    public double getDUTSensitiveRotationBeta() const; 

    /** 3D Euler rotation angle gamma of the DUT */
    public double getDUTSensitiveRotationGamma() const; 

    /** First element (cos(theta)) of rotation matrix of sensitive volume 
     * of the DUT.
     */
    public double getDUTSensitiveRotation1() const;
    /** Second element (-sin(theta)) of rotation matrix of sensitive volume 
     * of the DUT.
     */
    public double getDUTSensitiveRotation2() const;
    /** Third element (sin(theta)) of rotation matrix of sensitive volume 
     * of the DUT.
     */
    public double getDUTSensitiveRotation3() const;
    /** Fourth element (cos(theta)) of rotation matrix of sensitive volume 
     * of the DUT.
     */
    public double getDUTSensitiveRotation4() const;

}
